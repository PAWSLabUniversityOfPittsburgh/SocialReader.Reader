
<!-- saved from url=(0075)http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-3.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style>
body {
	font-family: Arial;

}

ul, li {
	font-family: Arial;
	font-size: 14px;
}

p {
	font-family: Arial;
	font-size: 15px;
	font-weight: none;
}

pre {

	font-family: Courier New;
	font-size: 12px;
	line-height: 12px;
}

.title {
		font-size: 20px;
			font-weight: bold;
}

.example {
		 
			color: green;

}

.hyper {
		 
			color: blue;

}

.cp {
	font-weight: bold;
}

.table {
	font-weight: bold;
}

.nav {
	font-family: Arial;
	font-size: 12px;
	}

.inchapter_nav {
	font-family: Arial;
	font-size: 12px;
	}
	h3.example {color: #009966; margin-top:0}
	div.example {
		color: #009966;
		margin-top: .1in;
		font-family: Arial, sans-serif;
		background-color: #FFFFEE; border:solid; border-width:1; padding:3; font-size: 80%
		}
	h3.hyper {color: #006699; margin-top:0}
	div.hyper {
		color: #006699;
		margin-top: .1in;
		font-family: Arial, sans-serif;
		background-color: #FFFFEE; border:solid; border-width:1; padding:3; font-size: 80%
		}	
</style>
<style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
<body>

<table bgcolor="#DDDDCC" width="100%" border="0" cellpadding="5" cellspacing="0">
<tbody><tr>
	
	<td align="center">
		<font size="4">
		<b>Task-Centered User Interface Design</b>
		</font>
		<font size="2">
		<br>A Practical Introduction
		</font>

	</td>
	
</tr>
<tr>
	<td align="center"><font size="2">
by
<font size="3">
<a href="http://www.cs.colorado.edu/~clayton/"><b>Clayton Lewis</b></a>
</font>
 and 
<font size="3">
<a href="http://home.att.net/~jrieman/"><b>John Rieman</b></a>

</font>
<br>

		Copyright ©1993, 1994: Please see the
		<a href="http://hcibib.org/tcuid/index.html#notice">"shareware notice"</a> at the front of the book.
	</font></td>
</tr>
</tbody></table>

<center><table border="0" cellspacing="0"><tbody><tr><td><a href="http://ir.exp.sis.pitt.edu/textbooks/hci/lewis/index.html"><font size="2">Contents</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/0.html"><font size="2">Foreword</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/1.html"><font size="2">ProcessUsers&amp;Tasks</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/2.html"><font size="2">Design</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/3.html"><font size="2">Inspections</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/4.html"><font size="2">User-testing</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/5.html"><font size="2">Tools</font></a> | </td><td bgcolor="#DDDDCC"><font size="2"><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6.html"><b><font color="black">Documentation</font></b></a></font> |</td></tr></tbody></table></center>
<br>
<div class="inchapter_nav">6.1 <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-1.html">Concepts</a></div><div class="inchapter_nav">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.1 <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-1-1.html">Object-Oriented Programming</a></div><div class="inchapter_nav">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.2 <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-1-2.html">Event-Driven Programs</a></div><div class="inchapter_nav">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.3 <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-1-3.html">Resources</a></div><div class="inchapter_nav">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.4 <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-1-4.html">Interapplication Communication</a></div><div class="inchapter_nav">6.2 <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-2.html">OSF/Motif in X-Windows -- Toolboxes in the Trenches</a></div><div class="inchapter_nav"><b>6.3 <a href="./6-3_files/6-3.html"><font color="black">Rapid Prototyping in HyperCard</font></a></b></div><div class="inchapter_nav">6.4 <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-4.html">Windows, the Shared-Code Approach, and Visual Basic</a></div>
<br>
<div class="nav">Prev <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-2.html">6.2 OSF/Motif in X-Windows -- Toolboxes in the Trenches</a> Next <a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6-4.html">6.4 Windows, the Shared-Code Approach, and Visual Basic</a></div>
<pre wrap="virtual"></pre>
<p class="title">6.3 Rapid Prototyping in HyperCard</p>
<pre wrap="virtual"></pre>
<p>The Apple II was Apple Computer's first big success. Indeed, it was the first big success of any personal computer outside the hobby market. Every Apple II included a BASIC language interpreter for users who wanted to write their own programs. When Apple introduced the Macintosh, many potential users were disappointed that it came without a standard programming language. HyperCard, introduced a few years later, is a low cost, low effort programming environment that answers some of those users' concerns. It goes well beyond BASIC in terms of the ease with which a graphical user interface can be created.</p>
<pre wrap="virtual"></pre>
<p>Programs written in the HyperCard environment are usually called "stacks" because they present a stack-of-index-cards metaphor. The HyperCard application itself is required not only to write but also to run a stack. Every new Macintosh comes with HyperCard Player, a version of the application that will run any stack but allows only limited programming.</p>
<pre wrap="virtual"></pre>
<p>HyperCard provides an object-oriented visual programming environment in which the user can create and customize three main classes of object: buttons and text fields, which are on-screen controls; and cards, which are individual windows that contain the buttons and fields. A HyperCard program for a personal phone list could be implemented as a stack of 26 cards, each with text fields containing names and phone numbers, and with buttons on each card labelled A through Z that take the user to the appropriate card. The phone list is exactly the kind of program HyperCard was designed for, and it would be supported by a number of built-in functions that the user can access through the standard run-time menus, such as "go to next card" and "find a string of text." Since all the cards are the same except for text content, they could even be implemented as a single class, called the "background."</p>
<pre wrap="virtual"></pre>
<p>The phone-list application can be programmed entirely by interacting with the visual programming environment -- selecting from menus, filling in dialog boxes, dragging buttons and fields into place. For more sophisticated applications, HyperCard provides a Pascal-like language called HyperTalk. HyperTalk procedures (handlers) are activated by messages from user controls and other procedures. For example, you might want to add a feature to the phone stack that would find all the names with a given area code. You could write a HyperTalk procedure that prompts the user for the area code, searches for that code in the area-code field of each card, and collects all the names into a new field. You'd associate that code with a new button, "Find Folks by Area Code," either by actually writing the code "in" the button itself (command-option-click the button to open it up), or by writing the code in the stack as a message handler and having the button send a message when clicked.</p>
<pre wrap="virtual"></pre>
<p>HyperCard is an interpreted language, so procedures can be tested as soon as you write them, with no compilation. But they don't run exceptionally fast, and they provide only limited access to the Macintosh operating system toolbox, which is needed to create standard interface objects such as general-purpose dialog boxes and scrolling windows. (Pulldown menus can be created with HyperTalk commands.) You can overcome these limitations by writing external functions and commands (XFCNs and XCMDs). These are procedures written in a programming language such as C or Pascal and incorporated into a HyperCard stack as code resources. They can be called from a HyperTalk procedure as if they were built-in HyperTalk functions.</p>
<pre wrap="virtual"></pre>
<p>We've found HyperCard to be very valuable for prototyping simple interfaces. An idea can be roughed out and shown to other designers in less than a day, and building enough functionality for early user testing won't take much longer. The system has two shortcomings. First, unless you use XCMDs and put in a lot of effort, the programs you develop look like HyperCard stacks, not like Macintosh programs. Even with external commands, menus and dialog boxes never become true objects in the visual programming environment. This makes HyperCard a good environment for prototyping things with buttons and text, like automatic teller machines, but not so good for prototyping Macintosh applications.</p>
<pre wrap="virtual"></pre>
<p>The second problem with HyperCard is that it wasn't intended to be a general purpose, full functionality programming environment. It's very good for simple prototypes or small applications that fit the stack-of-cards metaphor, but if you try to push beyond its limits you'll soon find yourself with a large, unwieldy program in an environment that has little support for modularity and versioning. In the worst case, you'll also be juggling functionality between XCMDs and HyperTalk. Together these problems are an invitation to some pretty flakey code.</p>
<pre wrap="virtual"></pre>
<p>HyperCard and similar programs are simple design tools, something like an artist's sketchpad, that you should have available and use when appropriate. For extended testing and final program delivery on the Mac, you will usually want a more powerful UIMS, either a visual environment or a programming language with object-oriented extensions supporting the target system's full toolbox of interface objects.</p>
<div class="example">
<h3 class="example"><a name="e1">Example: Experiences with HyperCard</a></h3>
<p>We've been using HyperCard for several years for prototyping and small applications. A typical project was an early, computer-based version of the cognitive walkthrough, which prompted users with detailed questions about an interface. The evaluator would click a Yes or a No button, or type in some text. The clever part of the application was that it could sometimes tell from the answer of one question that other questions could be skipped.</p>
<pre wrap="virtual"></pre>
<p>One of Clayton's graduate students roughed out the design in HyperCard, and we did a round of user testing with that prototype. The tests showed promise, and we decided to turn the prototype into a slicker application that we could give out for more feedback. John started to incorporate the changes suggested by user testing into the prototype, but he almost immediately decided to scrap the prototype entirely and rewrite everything, still working in HyperCard. The problems with the prototype weren't the fault of the original programmer. It's just that fast prototyping -- brainstorming on-line -- can lead to very sloppy code. That's a lesson that applies to other prototyping systems as well, although having the code distributed among various buttons, fields, and cards exacerbates the situation in HyperCard.</p>
<pre wrap="virtual"></pre>
<p>The basic rewrite in HyperCard only took about a week, plus a few more days for testing. That illustrates another fact about prototyping systems: if you've built a prototype once, duplicating it (neatly) in the same system can be trivial. However, duplicating the prototype in a different system can be very NON-trivial, because the new system typically doesn't support the same interaction techniques as the prototype.</p>
<pre wrap="virtual"></pre>
<p>Part of the redevelopment time was spent writing XCMDs in C to get around HyperCard's shortcomings. One of the routines changed upper to lower case, something HyperTalk could do but not fast enough. Another found commas in text that the user had typed in and changed them to vertical bars ("|"), because we were using some built-in HyperCard routines that mistook the user's commas for field delimiters. The bars had to be changed back into commas whenever the text was redisplayed for the user.</p>
<pre wrap="virtual"></pre>
<p>We gave out several copies of the walkthrough stack for comments. A couple of users reported that they couldn't get the stack to run. It turned out that they were running an earlier version of HyperCard. That illustrates another potential problem: HyperCard and some other UIM systems don't deliver stand-alone applications. The behavior of the code you deliver may depend on the version of the user's software. It may also depend on the options that the user has set for that software.</p>
<pre wrap="virtual"></pre>
<p>We stopped work on the walkthrough stack after we simplified the walkthrough process, but HyperCard might have been an adequate vehicle for final program delivery if the project had continued. The forms-oriented view that HyperCard supports was well suited to the simple walkthrough program. However, another project we started in HyperCard, the ChemTrains graphical programming language, outgrew the environment's capabilities after just a few weeks of work. Even though later versions of HyperCard have fixed some of the problems we had, our overall experience with the system recalls similar experiences with interpreted BASIC on other personal computers: projects get started very fast, but they soon bog down because of program size, poor support for modularity, and performance limitations.</p>
<pre wrap="virtual"></pre>
</div>
<br>

<table bgcolor="#DDDDCC" width="100%" border="0" cellpadding="5" cellspacing="0">
<tbody><tr><td align="center">
<font size="2">

<a href="http://hcibib.org/tcuid/index.html#notice" title="Please see shareware notice">Copyright © 1993,1994 Lewis &amp; Rieman</a>
</font>
</td></tr>
</tbody></table>

<center><table border="0" cellspacing="0"><tbody><tr><td><a href="http://ir.exp.sis.pitt.edu/textbooks/hci/lewis/index.html"><font size="2">Contents</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/0.html"><font size="2">Foreword</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/1.html"><font size="2">ProcessUsers&amp;Tasks</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/2.html"><font size="2">Design</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/3.html"><font size="2">Inspections</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/4.html"><font size="2">User-testing</font></a> | </td><td><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/5.html"><font size="2">Tools</font></a> | </td><td bgcolor="#DDDDCC"><font size="2"><a href="http://columbus.exp.sis.pitt.edu/socialreader/readings/books/lewis/6.html"><b><font color="black">Documentation</font></b></a></font> |</td></tr></tbody></table></center>


		</body></html>